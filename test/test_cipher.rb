#!/bin/env ruby


require_relative "../src/aes.rb"
require "test/unit"


class CipherTest < Test::Unit::TestCase

  def test_cipher_init()
    key_bytes = [0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
                 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]

    aeskey = AESKey.new(key_bytes)
    cipher = AESCipher.new
  end


  #==============================
  # Test internals
  #==============================

  def test_xor_round_key_128_key()
    key_bytes = [0x2b, 0x7e, 0x15, 0x16,
                 0x28, 0xae, 0xd2, 0xa6,
                 0xab, 0xf7, 0x15, 0x88,
                 0x09, 0xcf, 0x4f, 0x3c]

    aeskey = AESKey.new(key_bytes)
    cipher = AESCipher.new

    # Initial state before adding the round key
    state = [0x32, 0x88, 0x31, 0xe0,
             0x43, 0x5a, 0x31, 0x37,
             0xf6, 0x30, 0x98, 0x07,
             0xa8, 0x8d, 0xa2, 0x34]

    round_key = aeskey.round_keys[0..3]

    # xor initial state with round key
    cipher.xor_round_key(state, round_key, 4)

    # Expected state after adding the round key
    expected_state = [0x19, 0xa0, 0x9a, 0xe9,
                      0x3d, 0xf4, 0xc6, 0xf8,
                      0xe3, 0xe2, 0x8d, 0x48,
                      0xbe, 0x2b, 0x2a, 0x08]

    assert_equal(expected_state, state)
  end


  def test_sub_bytes_128_key()
    state = [0x19, 0xa0, 0x9a, 0xe9,
             0x3d, 0xf4, 0xc6, 0xf8,
             0xe3, 0xe2, 0x8d, 0x48,
             0xbe, 0x2b, 0x2a, 0x08]

    cipher = AESCipher.new
    cipher.sub_bytes(state, 4)

    # Expected state after substitution
    expected_state = [0xd4, 0xe0, 0xb8, 0x1e,
                      0x27, 0xbf, 0xb4, 0x41,
                      0x11, 0x98, 0x5d, 0x52,
                      0xae, 0xf1, 0xe5, 0x30]

    assert_equal(expected_state, state)
  end


  def test_shift_rows_128_key()
    state = [0xd4, 0xe0, 0xb8, 0x1e,
             0x27, 0xbf, 0xb4, 0x41,
             0x11, 0x98, 0x5d, 0x52,
             0xae, 0xf1, 0xe5, 0x30]

    cipher = AESCipher.new
    cipher.shift_rows(state, 4)

    expected_state = [0xd4, 0xe0, 0xb8, 0x1e,
                      0xbf, 0xb4, 0x41, 0x27,
                      0x5d, 0x52, 0x11, 0x98,
                      0x30, 0xae, 0xf1, 0xe5]

    assert_equal(expected_state, state)
  end


  def test_final_field_multiply()
    cipher = AESCipher.new
    assert_equal(cipher.ff_mul(0x57, 0x83), 0xc1)
  end


  def test_mix_columns_128_key()
    state = [0xd4, 0xe0, 0xb8, 0x1e,
             0xbf, 0xb4, 0x41, 0x27,
             0x5d, 0x52, 0x11, 0x98,
             0x30, 0xae, 0xf1, 0xe5]

    cipher = AESCipher.new
    cipher.mix_columns(state, 4)

    expected_state = [0x04, 0xe0, 0x48, 0x28,
                      0x66, 0xcb, 0xf8, 0x06,
                      0x81, 0x19, 0xd3, 0x26,
                      0xe5, 0x9a, 0x7a, 0x4c]

    assert_equal(expected_state, state)
  end


  def test_block_encrypt_128_key()
    key_bytes = [0x2b, 0x7e, 0x15, 0x16,
                 0x28, 0xae, 0xd2, 0xa6,
                 0xab, 0xf7, 0x15, 0x88,
                 0x09, 0xcf, 0x4f, 0x3c]

    aeskey = AESKey.new(key_bytes)
    cipher = AESCipher.new

    input_block = [0x32, 0x43, 0xf6, 0xa8,
                   0x88, 0x5a, 0x30, 0x8d,
                   0x31, 0x31, 0x98, 0xa2,
                   0xe0, 0x37, 0x07, 0x34]


    expected_output = [0x39, 0x25, 0x84, 0x1d,
                       0x02, 0xdc, 0x09, 0xfb,
                       0xdc, 0x11, 0x85, 0x97,
                       0x19, 0x6a, 0x0b, 0x32]

    cipher_text = cipher.encrypt_block(input_block, aeskey)

    assert_equal(cipher_text, expected_output)
  end


  def test_block_decrypt_128_key()
    key_bytes = [0x2b, 0x7e, 0x15, 0x16,
                 0x28, 0xae, 0xd2, 0xa6,
                 0xab, 0xf7, 0x15, 0x88,
                 0x09, 0xcf, 0x4f, 0x3c]

    aeskey = AESKey.new(key_bytes)
    cipher = AESCipher.new

    input_block = [0x39, 0x25, 0x84, 0x1d,
                   0x02, 0xdc, 0x09, 0xfb,
                   0xdc, 0x11, 0x85, 0x97,
                   0x19, 0x6a, 0x0b, 0x32]

    expected_output = [0x32, 0x43, 0xf6, 0xa8,
                       0x88, 0x5a, 0x30, 0x8d,
                       0x31, 0x31, 0x98, 0xa2,
                       0xe0, 0x37, 0x07, 0x34]

    plain_text = cipher.decrypt_block(input_block, aeskey)
    assert_equal(plain_text, expected_output)
  end

end
